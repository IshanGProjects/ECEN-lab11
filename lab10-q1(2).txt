module clock_divider (
    input mclk,
    output reg clk_1kHz,
    output reg clk_10kHz
);

// Counter to divide the clock
reg [15:0] counter;

// Divide clock and set output
always @(posedge mclk) begin
    if (counter == (50_000_000 / 1_000) - 1) begin
        counter <= 0;
        clk_1kHz <= ~clk_1kHz; // Toggle 1kHz output
    end
    else begin
        counter <= counter + 1;
    end
end

// Generate 10kHz clock
always @(posedge mclk) begin
    if (counter == (50_000_000 / 10_000) - 1) begin
        clk_10kHz <= ~clk_10kHz; // Toggle 10kHz output
    end
end

endmodule

module hexEncode(
    input [3:0] bin,
    input decimal_point, // New input to control decimal point
    output wire [7:0] hex
);
    wire A, B, C, D;

    assign A = bin[3];
    assign B = bin[2];
    assign C = bin[1];
    assign D = bin[0];

    assign hex[7] = ~decimal_point; 
    assign hex[6] = (~A & ~B & ~C & ~D) | (~A & ~B & ~C & D) | (~A & B & C & D);
    assign hex[5] = (~A & ~B & ~C & D) | (~A & ~B & C & ~D) | (~A & ~B & C & D) | (~A & B & C & D) | (A & B & ~C & D);
    assign hex[4] = (~A & ~B & ~C & D) | (~A & ~B & C & D) | (~A & B & ~C & ~D) | (~A & B & ~C & D) | (~A & B & C & D) | (A & ~B & ~C & D);
    assign hex[3] = (~A & ~B & ~C & D) | (~A & B & ~C & ~D) | (~A & B & C & D) | (A & ~B & C & ~D) | (A & B & C & D);
    assign hex[2] = (~A & ~B & C & ~D) | (A & B & ~C & ~D) | (A & B & C & ~D) | (A & B & C & D);
    assign hex[1] = (~A & B & ~C & D) |  (~A & B & C & ~D) | (A & ~B & C & D) |  (A & B & ~C & ~D) | (A & B & C & ~D) |  (A & B & C & D);
    assign hex[0] = (~A & B & ~C & ~D) | (A & ~B & C & D) | (A & B & ~C & D) | (~A&~B&~C&D);
endmodule


module display_4_hex(
    input [15:0] sw,
    input clk_10kHz,
    output [7:0] D0_seg, D1_seg,
    output [3:0] D0_a, D1_a
);

// Implement wires for segment components
wire [7:0] seg0, seg1, seg2, seg3;
hexEncode h0(sw[3:0], seg0);
hexEncode h1(sw[7:4], seg1);
hexEncode h2(sw[11:8], seg2);
hexEncode h3(sw[15:12], seg3);

// Use a counter to switch between displays
reg [3:0] display_counter;

always @(posedge clk_10kHz) begin
    display_counter <= display_counter + 1;
end

// Use ternary operators to select position from display_counter
assign D0_seg = (display_counter[1:0] == 2'b00) ? seg0 : (display_counter[1:0] == 2'b01) ? seg1 : (display_counter[1:0] == 2'b10) ? seg2 : seg3;
assign D0_a  = (display_counter[1:0] == 2'b00) ? 4'b1110 : (display_counter[1:0] == 2'b01) ? 4'b1101 : (display_counter[1:0] == 2'b10) ? 4'b1011 : 4'b0111;

endmodule

module top(
    input mclk,
    output [7:0] D1_seg,
    output [3:0] D1_a
);

// Instantiate clock_divider module
wire clk_1kHz;
wire clk_10kHz;
clock_divider clk_div(
    .mclk(mclk),
    .clk_1kHz(clk_1kHz),
    .clk_10kHz(clk_10kHz)
);

// Millisecond timer logic
reg [4:0] ms, cs, ds;

always @(posedge clk_1kHz) begin
    if (ms == 5'b10000) begin
        ms <= 0;
        if (cs == 5'b10000) begin
            cs <= 0;
            if (ds == 4'b1001) begin
                ds <= 0;
            end
            else begin
                ds <= ds + 1;
            end
        end
        else begin
            cs <= cs + 1;
        end
    end
    else begin
        ms <= ms + 1;
    end
end

wire [7:0] seg_ms, seg_cs, seg_ds;
hexEncode d0(ms[3:0], 1'b1, seg_ms); // Decimal point for ms
hexEncode d1(cs[3:0], 1'b1, seg_cs); // Decimal point for cs
hexEncode d2(ds[3:0], 1'b0, seg_ds); // No decimal point for ds

// Multiplex the displays
reg [2:0] display_sel;

always @(posedge clk_10kHz) begin
    display_sel <= display_sel + 1;
end

assign D1_seg = (display_sel == 3'b000) ? seg_ms : (display_sel == 3'b001) ? seg_cs : (display_sel == 3'b010) ? seg_ds : 8'b11111111;
assign D1_a = (display_sel == 3'b000) ? 4'b0111 : (display_sel == 3'b001) ? 4'b1011 : (display_sel == 3'b010) ? 4'b1101 : 4'b1111;

endmodule



