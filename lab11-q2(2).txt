`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 04/20/2023 02:04:47 PM
// Design Name: 
// Module Name: lab11-q1
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
module clock_divider (
    input mclk,
    output reg clk_1kHz,
    output reg clk_10kHz
);

// Counter to divide the clock
reg [23:0] counter;

// Divide clock and set output
always @(posedge mclk) begin
    if (counter == 50_000_000 / 1_000 - 1) begin
        counter <= 0;
        clk_1kHz <= ~clk_1kHz; // Toggle 1kHz output
    end
    else begin
        counter <= counter + 1;
    end

    if (counter == 50_000_000 / 10_000 - 1) begin
        clk_10kHz <= ~clk_10kHz; // Toggle 10kHz output
    end
end

endmodule

module hexEncode(
    input [3:0] bin,
    input decimal_point, // New input to control decimal point
    output wire [7:0] hex
);
    wire A, B, C, D;

    assign A = bin[3];
    assign B = bin[2];
    assign C = bin[1];
    assign D = bin[0];

    assign hex[7] = ~decimal_point; 
    assign hex[6] = (~A & ~B & ~C & ~D) | (~A & ~B & ~C & D) | (~A & B & C & D);
    assign hex[5] = (~A & ~B & ~C & D) | (~A & ~B & C & ~D) | (~A & ~B & C & D) | (~A & B & C & D) | (A & B & ~C & D);
    assign hex[4] = (~A & ~B & ~C & D) | (~A & ~B & C & D) | (~A & B & ~C & ~D) | (~A & B & ~C & D) | (~A & B & C & D) | (A & ~B & ~C & D);
    assign hex[3] = (~A & ~B & ~C & D) | (~A & B & ~C & ~D) | (~A & B & C & D) | (A & ~B & C & ~D) | (A & B & C & D);
    assign hex[2] = (~A & ~B & C & ~D) | (A & B & ~C & ~D) | (A & B & C & ~D) | (A & B & C & D);
    assign hex[1] = (~A & B & ~C & D) | (~A & B & C & ~D) | (A & ~B & C & D) | (A & B & ~C & ~D) | (A & B & C & ~D) | (A & B & C & D);
    assign hex[0] = (~A & B & ~C & ~D) | (A & ~B & C & D) | (A & B & ~C & D) | (~A&~B&~C&D);
endmodule


module top(
  input mclk,
  input BTN0,
  input BTN1,
  output [7:0] D1_seg,
  output [3:0] D1_a
);

// Instantiate clock_divider module
wire clk_1kHz;
wire clk_10kHz;
clock_divider clk_div(
  .mclk(mclk),
  .clk_1kHz(clk_1kHz),
  .clk_10kHz(clk_10kHz)
);

// Millisecond timer logic
reg [3:0] ms, cs, ds, ss;
reg timer_running = 0;
reg btn0_state, btn1_state;

always @(posedge mclk) begin
  btn0_state <= BTN0;
  btn1_state <= BTN1;

  if (btn0_state == 1'b0) begin
    ms <= 0;
    cs <= 0;
    ds <= 0;
    ss <= 0;
  end

  if (btn1_state == 1'b0) begin
    timer_running <= ~timer_running;
  end

  if (timer_running) begin
    if (ms == 4'b1001) begin
      ms <= 0;
      if (cs == 4'b1001) begin
        cs <= 0;
        if (ds == 4'b1001) begin
          ds <= 0;
          if (ss == 4'b1001) begin
            ss <= 0;
          end
          else begin
            ss <= ss + 1;
          end
        end
        else begin
          ds <= ds + 1;
        end
      end
      else begin
        cs <= cs + 1;
      end
    end
    else begin
      ms <= ms + 1;
    end
  end
end

// Display multiplexing logic
reg [1:0] digit_sel = 2'b00;

always @(posedge clk_1kHz) begin
  digit_sel <= digit_sel + 1;
  case (digit_sel)
    2'b00: begin
      D1_seg <= {1'b0, 1'b0, 1'b0, ss[0]};
      D1_a <= 4'b1110;
    end
    2'b01: begin
      D1_seg <= {1'b0, 1'b0, 1'b1, ss[1:0]};
      D1_a <= 4'b1101;
    end
    2'b10: begin
      D1_seg <= {1'b0, 1'b1, 1'b0, ds[0]};
      D1_a <= 4'b1011;
    end
    2'b11: begin
      D1_seg <= {1'b0, 1'b1, 1'b1, ds[1:0]};
      D1_a <= 4'b0111;
    end
  endcase
end

endmodule
